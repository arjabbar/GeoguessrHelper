const GEOGUESSR_ORIGIN = 'https://www.geoguessr.com/';



/**
 * Retrieves the vision response from the OpenAI API.
 * 
 * @param {string} dataUrl - The URL of the image to analyze.
 * @returns {Promise<void>} - A promise that resolves when the response is received.
 * 
 * @typedef {Object} VisionResponse
 * @property {string} id - The ID of the chat completion.
 * @property {string} object - The type of object, which is "chat.completion".
 * @property {number} created - The timestamp of when the response was created.
 * @property {string} model - The model used for the completion.
 * @property {Object} usage - The token usage statistics.
 * @property {number} usage.prompt_tokens - The number of tokens used in the prompt.
 * @property {number} usage.completion_tokens - The number of tokens used in the completion.
 * @property {number} usage.total_tokens - The total number of tokens used.
 * @property {Object[]} choices - The choices made by the model.
 * @property {Object} choices.message - The message generated by the model.
 * @property {string} choices.message.role - The role of the message, which can be "assistant" or "user".
 * @property {string} choices.message.content - The content of the message.
 * @property {string} choices.finish_reason - The reason for finishing the completion.
 * @property {number} choices.index - The index of the choice.
 */
async function getVisionResponse(dataUrl, shortAnswer) {
  const { apiKey, selectedModel } = await chrome.storage.local.get([
    'apiKey',
    'selectedModel'
  ]);

  const gptPrompt = shortAnswer
    ? `You are a master Geoguessr expert.
Return ONLY valid JSON that strictly conforms to the provided JSON Schema. Do not include Markdown or HTML.`
    : `You are a helpful Geoguessr Coach.
Return ONLY valid JSON that strictly conforms to the provided JSON Schema. Do not include Markdown or HTML.`;

  const abortController = new AbortController();
  // Abort the request after 30 seconds
  setTimeout(() => abortController.abort(), 30000);

  // Different schema for short answers vs thorough answers
  const schema = shortAnswer ? {
    type: "object",
    additionalProperties: false,
    required: ["city", "region", "country"],
    properties: {
      city: { type: "string", description: "The most likely city name based on the screenshot" },
      region: { type: "string", description: "The region/state/province" },
      country: { type: "string", description: "The country" }
    }
  } : {
    type: "object",
    additionalProperties: false,
    required: ["mode", "summary", "is_quiz", "quiz_answer", "guesses", "tips"],
    properties: {
      mode: { type: "string", enum: ["short","coach"] },
      summary: { type: "string", description: "1â€“2 line overall take." },
      is_quiz: { type: "boolean" },
      quiz_answer: { type: "string" },
      guesses: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          additionalProperties: false,
          required: ["label", "country", "region", "confidence", "reasons", "clues", "coordinates"],
          properties: {
            label:      { type: "string", description: "City/region/country or final guess label" },
            country:    { type: "string" },
            region:     { type: "string" },
            confidence: { type: "number", minimum: 0, maximum: 1 },
            reasons:    { type: "array", items: { type: "string" }, description: "Short bullets: why" },
            clues:      { type: "array", items: { type: "string" }, description: "Evidence spotted" },
            coordinates:{ type: "object", additionalProperties:false, required:["lat","lng"], properties:{
              lat:{type:"number"}, lng:{type:"number"}
            }}
          }
        }
      },
      tips: { type:"array", items:{ type:"string" }, description:"Coach mode: how to get better next time" }
    }
  };

  const userPrompt = shortAnswer
    ? "Look at this Geoguessr screenshot and identify the most likely location. Return the city, region, and country in the JSON format without any explanations or reasoning."
    : "Analyze the screenshot and reply as JSON only. No commentary.";

  const requestBody = JSON.stringify({
    model: selectedModel || 'gpt-4.1-mini',
    input: [
      {
        role: 'system',
        content: [{ type: 'input_text', text: gptPrompt }]
      },
      {
        role: 'user',
        content: [
          {
            type: 'input_text',
            text: userPrompt
          },
          // dataUrl is already a data: URI (jpeg base64) from captureVisibleTab
          { type: 'input_image', image_url: dataUrl }
        ]
      }
    ],
    text: {
      format: {
        type: "json_schema",
        name: "geoguessr_response",
        description: shortAnswer ? "Simple city name response" : "Structured location guesses from a Geoguessr screenshot",
        schema: schema,
        strict: true
      }
    }
  });

  const response = await fetch('https://api.openai.com/v1/responses', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: requestBody,
    signal: abortController.signal
  });

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error(
        "You have exceeded your API token limit. Please check your Open AI account to ensure you haven't hit your usage limits."
      );
    } else {
      throw new Error(`Failed to get vision API response: ${response.status} ${response.statusText}`);
    }
  }

  const json = await response.json();

  // Usage fields differ slightly on Responses API but still include total tokens
  console.info(json?.usage?.total_tokens, 'tokens used.');

  // Prefer output_text helper; fall back to stitching output[].content[].text
  const text =
    json.output_text ??
    (Array.isArray(json.output)
      ? json.output
          .map(m => (m.content || []).map(c => c.text || '').join(''))
          .join('\n')
      : '');

  return text;
};

function isGeoguessr(url) {
  if (!url) return false;
  try {
    const urlObj = new URL(url);
    return GEOGUESSR_ORIGIN.startsWith(urlObj.origin);
  } catch (error) {
    console.error('Failed to parse URL', url, error);
    return false;
  }
}

chrome.runtime.onMessage.addListener(async function(request, sender, sendResponse) {
  console.log('background.js', request.message);

  if (request.message === 'captureScreen') {
    try {
      chrome.runtime.sendMessage({message: "startThinking"});

      // Get the active tab's url and make sure that we're on the Geoguessr site
      const tab = (await chrome.tabs.query({active: true, currentWindow: true}))[0];
      if (!isGeoguessr(tab.url)) {
        chrome.runtime.sendMessage({message: "captureResponseReceived", response: "This is not a Geoguessr website. Please navigate to a Geoguessr website to use this extension."});
        return true;
      }

      const dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, {format: "jpeg", quality: 80});
      console.log(dataUrl);
      chrome.runtime.sendMessage({message: "updateScreenshot", dataUrl: dataUrl});
  
      // send this image to Open AI Vision API and log the response
      const response = await getVisionResponse(dataUrl, request.shortAnswer);

      console.log(response);

      chrome.runtime.sendMessage({message: "captureResponseReceived", response});
    } catch (error) {
      console.error('Failed to capture screenshot.', error);
      chrome.runtime.sendMessage({message: "captureResponseReceived", error: (error?.message || error)});
    }
  }

  return true;
});

// Add a hotkey to trigger something
chrome.commands.onCommand.addListener(function(command) {
  console.log('Command:', command);
  if (command === 'captureScreen') {
    chrome.runtime.sendMessage({message: "captureScreen"});
  }
});